	<section id="chap-publish" class="chapter">
		<h2>Publication</h2>
		<p>While it may not always be desirable to publish knowledge graphs (for example, those that offer a competitive advantage to a company&nbsp;<? echo $references->cite("NoyGJNPT19"); ?>, it may be desirable or even required to publish other knowledge graphs, such as those produced by volunteers&nbsp;<? echo $references->cite("VrandecicK14,MahdisoltaniBS15,LehmannIJJKMHMK15"); ?>, by publicly-funded research&nbsp;<? echo $references->cite("CallahanCAD13,GrothLGGHP14,uniprot2014"); ?>, by governmental organisations&nbsp;<? echo $references->cite("HendlerHMT12,ShadboltO13"); ?>. Publishing refers to making the knowledge graph (or part thereof) accessible to the public, often on the Web. Knowledge graphs published as open data are called open knowledge graphs (discussed in Section&nbsp;<? echo ref("sec:openkgs"); ?>).</p>
		<p>In the following, we first discuss two sets of principles that have been proposed to guide the publication of data on the Web. We next discuss access protocols by which the public can interact with the content of a knowledge graph. Finally, we consider techniques to restrict the access or usage of (parts of) a knowledge graph.</p>

		<section id="ssec-principles" class="section">
		<h3>Best Practices</h3>
		<p>We now discuss two key sets of publishing principles: the FAIR Principles&nbsp;<? echo $references->citet("wilkinson2016fair"); ?>, and the Linked Data Principles&nbsp;<? echo $references->cite("ldprinciples"); ?>.</p>

		<h4 id="ssec-fair" class="subsection">FAIR Principles</h4>
		<p>The FAIR Principles were originally proposed in the context of publishing scientific data&nbsp;<? echo $references->cite("wilkinson2016fair"); ?> – particularly motivated by maximising the impact of publicly-funded research – but the principles generally apply to other situations where data are to be published in a manner that facilitates their re-use by external agents, with particular emphasis on machine-readability.</p>
		<p>FAIR itself is an acronym for four foundational principles, each with particular goals&nbsp;<? echo $references->cite("wilkinson2016fair"); ?>, that may apply to <em>data</em>, <em>metadata</em>, or both – the latter being denoted <em>(meta)data</em>.<? echo footnote("Metadata are data about data. The distinction is often important in observational sciences, where in astronomy, for example, data may include raw image data, while metadata may include coordinates and time."); ?> We now describe the FAIR principles (slightly rephrasing the original wording in some cases for brevity&nbsp;<? echo $references->cite("wilkinson2016fair"); ?>).</p>
		
		<ul>
			<li><em>Findability</em> refers to the ease with which external agents who might benefit from the dataset can initially locate the dataset. Four sub-goals should be met:<ul>
				<li>F1: (meta)data are assigned a globally unique and persistent identifier.</li>
				<li>F2: data are described with rich metadata (see R1).</li>
				<li>F3: metadata explicitly include the identifier of the data they describe.</li>
				<li>F4: (meta)data are registered or indexed in a searchable resource.</li>
			</ul></li>
			<li><em>Accessibility</em> refers to the ease with which external agents can access the dataset (after locating it). Two goals are defined, the first with two sub-goals:<ul>
				<li>A1: (meta)data are retrievable by their identifier via a standard protocol.<ul>
					<li>A1.1: the protocol is open, free, and universally implementable.</li>
					<li>A1.2: the protocol uses authentication and authorisation if suitable.</li>
				</ul></li>
				<li>A2. metadata are accessible, even when the data are no longer available.</li>
			</ul></li>
			<li><em>Interoperability</em> refers to the ease with which the dataset can be exploited (in unison with other datasets) using standard tools. Three goals are defined:<ul>
				<li>I1: meta)data use an accessible, agreed-upon, and general knowledge representation formalism.</li>
				<li>I2: (meta)data use vocabularies that follow FAIR principles.</li>
				<li>I3: (meta)data include qualified references to other (meta)data.</li>
			</ul></li>
			<li><em>Reusability</em> refers to the ease with which the dataset can be re-used in conjunction with other datasets. One goal is defined (with three sub-goals):<ul>
				<li>R1: meta(data) are richly described with accurate and relevant attributes.<ul>
					<li>R1.1. (meta)data are released with a clear and accessible license.</li>
					<li>R1.2. (meta)data are associated with detailed provenance.</li>
					<li>R1.3. (meta)data meet domain-relevant community standards.</li>
				</ul></li>
			</ul></li>
		</ul>
		<p>In the context of knowledge graphs, a variety of vocabularies, tools, and services have been proposed that both directly and indirectly help to satisfy the FAIR principles. In terms of <em>Findability</em>, as discussed in Chapter&nbsp;<? echo ref("chap:graph"); ?>, IRIs are built into the RDF model, providing a general schema for global identifiers. In addition, resources such as the Vocabulary of Interlinked Datasets (VoID)&nbsp;<? echo $references->cite("AlexanderCHZ09"); ?> allow for representing metadata about graphs, while services such as DataHub&nbsp;<? echo $references->cite("BhardwajBCDEMP15"); ?> provide a central repository of such dataset descriptions. Access protocols that enable <em>Accessibility</em> will be discussed in Section&nbsp;<? echo ref("ssec:access"); ?>, while mechanisms for authorisation will be discussed in Section&nbsp;<? echo ref("ssec:UsageControl"); ?>. With respect to <em>Interoperability</em>, as discussed in Chapter&nbsp;<? echo ref("chap:deductive"); ?>, ontologies serve as a general knowledge representation formalism, and can in turn be used to describe vocabularies that follow FAIR principles. Regarding <em>Reusability</em>, licensing will be discussed in Section&nbsp;<? echo ref("ssec:UsageControl"); ?>, while the <em>PROV Data Model</em>&nbsp;<? echo $references->cite("prov13"); ?> discussed in Chapter&nbsp;<? echo ref("chap:knowledge"); ?>, can encode provenance in detail.</p>
		<p>Various knowledge graphs have been published using FAIR principles, where <? echo $references->citet("wilkinson2016fair"); ?> explicitly mention Open PHACTS&nbsp;<? echo $references->cite("GrothLGGHP14"); ?>, a data integration platform for drug discovery, and UniProt&nbsp;<? echo $references->cite("uniprot2014"); ?>, a large collection of protein sequence and annotation data, as conforming to FAIR principles. Both datasets offer graph views of their content through RDF.</p>

		<h4 id="sssec-ld" class="subsection">Linked Data Principles</h4>
		<p><? echo $references->citet("wilkinson2016fair"); ?> state that FAIR Principles “precede implementation choices”, meaning that the principles do not cover <em>how</em> they can or should be achieved. Preceding the FAIR Principles by almost a decade are the Linked Data Principles, proposed by <? echo $references->citet("ldprinciples"); ?>, which provide a technical basis for one possible way in which these FAIR Principles can be achieved. Specifically the Linked Data Principles are as follows:</p>
		<ol>
			<li>Use IRIs as names for things.</li>
			<li>Use HTTP IRIs so those names can be looked up.</li>
			<li>When a HTTP IRI is looked up, provide useful content about the entity that the IRI names using standard data formats.</li>
			<li>Include links to the IRIs of related entities in the content returned.</li>
		</ol>
		<p>These principles were proposed in a Semantic Web setting, where for principle&nbsp;(3), the standards based on RDF (including RDFS, OWL, etc.) are currently recommended for use, particularly because they allow for naming entities using HTTP IRIs, which further paves the way for satisfying all four principles. As such, these principles outline a way in which (RDF) graph-structured data can be published on the Web such that these graphs are interlinked to form what <? echo $references->citet("ldprinciples"); ?> calls a “Web of Data”, whose goal is to increase automation on the Web by making content available not only in (HTML) documents intended for human consumption, but also as (RDF) structured data that machines can locate, retrieve, combine, validate, reason over, query over, etc., towards solving tasks automatically&nbsp;<? echo $references->cite("Hogan20a"); ?>. Conceptually, the Web of Data is then composed of graphs of data published on individual web-pages, where one can click on a node or edge-label – or more precisely perform a HTTP lookup on an IRI of the graph – to be transported to another graph elsewhere on the Web with relevant content for that node or edge-label, and so on recursively.</p>
		<p>Figure&nbsp;<? echo ref("fig:ld"); ?> provides a small example with two Linked Data documents published on the Web, with each containing an RDF graph. As discussed in Section&nbsp;<? echo ref("sec:identity"); ?>, terms such as <code>clv:Concert</code>, <code>wd:Q142701</code>, <code>rdfs:label</code>, etc., are abbreviations for IRIs, where, for example, <code>wd:Q142701</code> expands to <a class="uri" href="http://www.wikidata.org/entity/Q142701">http://www.wikidata.org/entity/Q142701</a>. Prefixes beginning with <code>cl</code> are fictitious prefixes we assume to have been created by the Chilean tourist board. The IRIs prefixed with <span style="color:#bf0040;">\(\hookrightarrow\)<img style="position:relative;top:0.2em;margin-left:0.1em;" src="images/earth.png" width="16" alt="Earth"/></span> indicate the document returned if the node is looked up. The leftmost document is published by the tourist board and describes Lollapalooza 2018 (identified by the node <span class="gnode">cle:LP2018</span>), which links to the headlining act Pearl Jam (<span class="gnode">wd:Q142701</span>) described by an external knowledge graph, namely Wikidata. By looking up the node <span class="gnode">wd:Q142701</span> in the leftmost graph, the IRI <em>dereferences</em> (i.e., returns via HTTP) the document with the RDF graph on the right describing that entity in more detail. From the rightmost document, the node <span class="gnode">wd:Q221535</span> can be looked up, in turn, to find a graph about Eddie Vedder (not shown in the example). The IRIs for entities and documents are distinguished to ensure that we do not confuse data about the entity and the document; for example, while <code>wd:Q221535</code> refers to Eddie Vedder, the IRI <code style="color:#bf0040">wd<strong>d</strong>:Q221535</code> refers to the document about Eddie Vedder; if we were to assign a last-modified date to the document, we should use <span class="gnode" style="color:#bf0040">wd<strong>d</strong>:Q221535</span> not <span class="gnode">wd:Q221535</span>. In Figure&nbsp;<? echo ref("fig:ld"); ?>, we can further observe that edge labels (which are also IRIs) and nodes representing classes (e.g., <span class="gnode">clv:Concert</span>) can also be dereferenced, typically returning semantic definitions of the respective terms.</p>

		<figure id="fig-ld">
			<img src="images/fig-ld.svg" alt="Two example Linked Data documents from two websites, each containing an RDF graph, where wd:Q142701 refers to Pearl Jam in Wikidata while wdd:Q142701 refers to the RDF graph about Pearl Jam, and where wd:Q221535 refers to Eddie Vedder while wdd:Q221535 refers to the RDF graph about Eddie Vedder; the edge-label wdt:571 refers to “inception” in Wikidata, while wdt:527 refers to “has part”"/>
			<figcaption>Two example Linked Data documents from two websites, each containing an RDF graph, where <code>wd:Q142701</code> refers to Pearl Jam in Wikidata while <code>wdd:Q142701</code> refers to the RDF graph about Pearl Jam, and where <code>wd:Q221535</code> refers to Eddie Vedder while <code>wdd:Q221535</code> refers to the RDF graph about Eddie Vedder; the edge-label <span class="gelab">wdt:571</span> refers to “inception” in Wikidata, while <span class="gelab">wdt:527</span> refers to “has part”</figcaption>
		</figure>

		<p>A key challenge is posed by the fourth principle – include links to related entities – as illustrated in Figure&nbsp;<? echo ref("fig:ld"); ?>, where <span class="gnode">wd:Q221535</span> in the leftmost graph constitutes a link to related content about Pearl Jam in an external knowledge graph. Specifically, the <em>link discovery</em> task considers adding such links from one knowledge graph to another, which may involve inclusion of IRIs that dereference to external graphs (per Figure&nbsp;<? echo ref("fig:ld"); ?>), or links with special semantics such as identity links. In comparison with the link prediction task discussed in Section&nbsp;<? echo ref("ssec:completion"); ?>, which is used to complete links within a knowledge graph, link discovery aims to discover links across knowledge graphs, which involves unique aspects: first, link discovery typically considers disjoint sets of source (local) nodes and target (remote) nodes; second, the knowledge graphs may often use different vocabularies; third, while in link prediction there already exist local examples of the links to predict, in link discovery, there are often no existing links between knowledge graphs to learn from. A common technique is to define manually-crafted linkage rules (aka link specifications) that apply heuristics for defining links that potentially incorporate similarity measures&nbsp;<? echo $references->cite("NgomoA11,silk"); ?>. Link discovery is greatly expedited by the provision of standard identifier schemes within knowledge graphs, such as ISBNs for books, alpha-2 and alpha-3 codes for countries (e.g., <span class="sc">cl</span>, <span class="sc">clp</span>), or even links to common knowledge graphs such as DBpedia&nbsp;<? echo $references->cite("LehmannIJJKMHMK15"); ?> or Wikidata&nbsp;<? echo $references->cite("VrandecicK14"); ?> (that themselves include standard identifiers). We refer to the survey on link discovery by <? echo $references->citet("nentwig2017survey"); ?> for more details.</p>
		<p>More finer-grained recommendations for publishing Linked Data have also been proposed, relating to how best to implement dereferencing, what kinds of links to include, how to publish and interlink vocabularies, amongst other considerations&nbsp;<? echo $references->cite("ldbook,JanowiczHAKV14"); ?>. We refer to the book by <? echo $references->citet("ldbook"); ?> for more discussion on how to publish Linked Data on the Web.</p>
		</section>

		<section id="ssec-access" class="section">
		<h3>Access Protocols</h3>
		<p>Publishing involves giving access to the public to interact with the knowledge graph, which implies the provision of <em>access protocols</em> that define the requests that agents can make and the response that they can expect as a result. Per the <em>Accessibility</em> principle of FAIR (specifically A1.1), this protocol should be open, free, and universally implementable. In the context of knowledge graphs, as shown in Figure&nbsp;<? echo ref("fig:access"); ?>, there are a number of access protocols to choose from, varying from simple protocols that allow users to simply download all content, towards protocols that accept and evaluate increasingly complex requests. While simpler protocols require less computation on the server that publishes the data, more complex protocols allow agents to request more specific data, thus reducing bandwidth. A knowledge graph may also offer a variety of access protocols catering to different agents with different requirements&nbsp;<? echo $references->cite("VerborghSCCMW14"); ?>. We now discuss such access protocols.</p>

		<figure id="fig-access">
			<img src="images/fig-access.svg" alt="Access protocols for knowledge graphs, from simple protocols (left) to more complex protocols (right)"/>
			<figcaption>Access protocols for knowledge graphs, from simple protocols (left) to more complex protocols (right)</figcaption>
		</figure>

		<h4 id="sssec-dumps" class="subsection">Dumps</h4>
		<p>A dump is a file or collection of files containing the content of the knowledge graph available for download. The request in this case is for the file(s) and the response is the content of the file(s). In order to publish dumps, first of all, concrete – and ideally standard – syntaxes are required to serialise the graph. While for RDF graphs there are various standard syntaxes available based on XML&nbsp;<? echo $references->cite("rdfxml11"); ?>, JSON&nbsp;<? echo $references->cite("jsonld"); ?>, custom syntaxes&nbsp;<? echo $references->cite("turtle"); ?>, and more besides, currently there are only non-standard syntaxes available for property graphs&nbsp;<? echo $references->cite("TomaszukASLC19"); ?>. Second, to reduce bandwidth, compression methods can be applied. While standard compression such as GZIP or BZip2 can be straightforwardly applied on any file, custom compression methods have been proposed for graphs that not only offer better compression ratios than these standard methods, but also offer additional functionalities, such as compact indexes for performing efficient lookups once the file is downloaded&nbsp;<? echo $references->cite("FernandezMGPA13"); ?>. Finally, to further reduce bandwidth, when the knowledge graph is updated, “diffs” can be computed and published to obviate the need for agents to download all data from scratch (see&nbsp;<? echo $references->cite("TummarelloMBE07,PapavasileiouFFKC13,AhnIEZK14"); ?>). Still, however, dumps are only suited to certain use-cases, in particular for agents that wish to maintain a full local copy of a knowledge graph. If an agent were rather only interested in, for example, all food festivals in Santiago, downloading the entire dump may require transferring and processing a lot of irrelevant data.</p>

		<h4 id="sssec-node-lookups" class="subsection">Node lookups</h4>
		<p>Protocols for performing node lookups accept a node (id) request (e.g., <span class="gnode">cle:LP2018</span> in Figure&nbsp;<? echo ref("fig:ld"); ?>) and return a (sub-)graph describing that node (e.g., the document <code style="color:#bf0040">cld:LP2018</code>). Such a protocol is the basis for the Linked Data principles outlined previously, whereby node lookups are implemented through HTTP dereferencing, which further allows nodes in remote graphs to be referenced from across the Web. Although there are varying definitions on what content should be returned for a node&nbsp;<? echo $references->cite("cbd"); ?>, a common convention is to return a sub-graph containing either all outgoing edges for that node or all incident edges (both outgoing and incoming) for that node&nbsp;<? echo $references->cite("HoganUHCPD12"); ?>. Though simple, mechanisms for evaluating graph patterns can be implemented on top of a node lookup interface by traversing from node to node per the particular graph pattern&nbsp;<? echo $references->cite("HartigBF09"); ?>; for example, to find all food festivals in Santiago – represented by the graph pattern <span class="gnode">Food Festival</span><? echo etipl(); ?><span class="edge">type</span><? echo esource(); ?><span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">location</span><? echo etipr(); ?><span class="gnode">Santiago</span> – we may perform a node lookup for <span class="gnode">Santiago</span>, subsequently performing a node lookup for each node connected by a <span class="gelab">location</span> edge to <span class="gnode">Santiago</span>, returning those nodes declared to be of type <span class="gnode">Food Festival</span>. However, such an approach may not be feasible if no starting node is declared (e.g., if all nodes are variables), if the node lookup service does not return incoming edges, etc. The client agent may also need to request more data than necessary; for example, the document returned for <span class="gnode">Santiago</span> may return a lot of data irrelevant to the query, and nodes with a <span class="gelab">location</span> in <span class="gnode">Santiago</span> that are not instances of <span class="gnode">Food Festival</span> still need to be looked up to check their type. Node lookups are relatively inexpensive for servers to support in terms of CPU, but may again waste bandwidth due to transferring irrelevant data.</p>

		<h4 id="sssec-edge-patterns" class="subsection">Edge patterns</h4>
		<p>Edge patterns – also known as <em>triple patterns</em> in the case of directed, edge-labelled graphs – are singleton graph patterns, i.e., graph patterns with a single edge. Examples of edge patterns are <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">type</span><? echo etipr(); ?><span class="gnode">Food Festival</span> or <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">location</span><? echo etipr(); ?><span class="gnode">Santiago</span>, etc., where any term can be a variable or a constant. A protocol for edge patterns accepts such a pattern and returns all solutions for the pattern. Edge patterns provide more flexibility than node lookups, where graph patterns are more readily decomposed into edge patterns than node lookups. With respect to the agent interested in food festivals in Santiago, they can first, for example, request solutions for the edge pattern <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">location</span><? echo etipr(); ?><span class="gnode">Santiago</span> and locally join/intersect these solutions with those of <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">type</span><? echo etipr(); ?><span class="gnode">Food Festival</span>. Given that some edge patterns (e.g., <span class="gvar"><strong>?x</strong></span><? echo esource(); ?><span class="sf"><strong>?y</strong></span><? echo etipr(); ?><span class="gvar"><strong>?z</strong></span>) can return many solutions, protocols for edge patterns may offer additional practical features such as iteration or pagination over results&nbsp;<? echo $references->cite("VerborghSHHVMHC16"); ?>. Much like node lookups, the server cost of responding to a request is relatively low and easy to predict. However, the server may often need to transfer irrelevant intermediate results to the client, which in the previous example may involve returning nodes located in Santiago that are not food festivals. This issue is further aggravated if the client does not have access to statistics about the knowledge graph in order to plan how to best perform the join; for example, if there are relatively few food festivals but many things located in Santiago, rather than intersecting the solutions of the two aforementioned edge patterns, it should be more efficient to send a request for each food festival to see if it is in Santiago, but deciding this requires statistics about the knowledge graph. Extensions to the edge-pattern protocol have thus been proposed to allow for more efficient joins&nbsp;<? echo $references->cite("HartigLP17"); ?>, such as allowing batches of solutions to be sent alongside the edge pattern to only return solutions compatible with the solutions in the request&nbsp;<? echo $references->cite("HartigA16"); ?> (e.g., sending a batch of solutions for <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">type</span><? echo etipr(); ?><span class="gnode">Food Festival</span> to join with the solutions for the request <span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">location</span><? echo etipr(); ?><span class="gnode">Santiago</span>).</p>

		<h4 id="sssec-graph-patterns" class="subsection">(Complex) graph patterns</h4>
		<p>Another alternative is to let client agents make requests based on (complex) graph patterns (see Section&nbsp;<? echo ref("ssec:querying"); ?>), with the server returning (only) the final solutions. In our running example, this involves the client issuing a request for <span class="gnode">Food Festival</span><? echo etipl(); ?><span class="edge">type</span><? echo esource(); ?><span class="gvar"><strong>?ff</strong></span><? echo esource(); ?><span class="edge">location</span><? echo etipr(); ?><span class="gnode">Santiago</span> and directly receiving the relevant results. Compared with the previous protocols, this protocol is much more efficient in terms of bandwidth: it allows clients to make more specific requests and the server to return more specific responses. However, this reduction in bandwidth use comes at the cost of the server having to evaluate much more complex requests, where, furthermore, the costs of a single request are much more difficult to anticipate. While a variety of optimised engines exist for evaluating (complex) graph patterns (e.g.,&nbsp;<? echo $references->cite("virtuoso,Miller13,ThompsonPC14"); ?> amongst many others), the problem of evaluating such queries is known to be intractable&nbsp;<? echo $references->cite("AnglesABHRV17"); ?>. Perhaps for this reason, public services offering such a protocol (most often supporting SPARQL queries&nbsp;<? echo $references->cite("sparql11"); ?>) have been found to often exhibit downtimes, timeouts, partial results, slow performance, etc.&nbsp;<? echo $references->cite("ArandaHUV13"); ?>. Even considering such issues, however, popular services continue to receive – and successfully evaluate – millions of requests/queries per day&nbsp;<? echo $references->cite("malyshev2018getting,SaleemAHMN15"); ?>, with difficult (worst-case) instances being rare in practice&nbsp;<? echo $references->cite("BonifatiMT17"); ?>.</p>

		<h4 id="sssec-other-protocols" class="subsection">Other protocols</h4>
		<p>While Figure&nbsp;<? echo ref("fig:access"); ?> makes explicit reference to some of the most commonly-encountered access protocols found for knowledge graphs in practice, one may of course imagine other protocols lying almost anywhere on the spectrum from more simple to more complex interfaces. To the right of (Complex) Graph Patterns, one could consider supporting even more complex requests, such as queries with entailments&nbsp;<? echo $references->cite("Glimm11"); ?>, queries that allow recursion&nbsp;<? echo $references->cite("ReutterSV15"); ?>, federated queries that can join results from remote services&nbsp;<? echo $references->cite("ArandaACP13"); ?>, or even (hypothetically) supporting Turing-complete requests that allow running arbitrary procedural code on a knowledge graph. As mentioned at the outset, a server may also choose to support multiple, complementary protocols&nbsp;<? echo $references->cite("VerborghSCCMW14"); ?>.</p>
		</section>

		<section id="ssec-UsageControl" class="section">
		<h3>Usage Control</h3>
		<p>Considering our hypothetical tourism knowledge graph, at first glance, one might assume that the knowledge required to deliver the envisaged services is public and thus can be used both by the tourism board and the tourists. On closer inspection, however, we may see the need for usage control in various forms:</p>
		<ul class="inline-ul roman">
			<li>both the tourist board and its partners should associate an appropriate license with knowledge that they contribute to the knowledge graph, such that the terms of use are clear to all interested parties;</li>
			<li>a tourist might opt to install an app on their mobile phone that could be used to recommend tourist attractions based on their location, bringing with it potential privacy concerns regarding who has access to their location;</li>
			<li>the tourist board may be required to report criminal activities to the police services and thus may need to encrypt personal information; and</li>
			<li>the tourist board could potentially share information relating to tourism demographics in an anonymous format to allow for other agencies and companies to anticipate demand and improve transport infrastructure on strategic routes.</li>
		</ul>
		<p>Thus in this section, we examine the state of the art in terms of knowledge graph licensing, usage policies, encryption, and anonymisation.</p>

		<h4 id="sssec-licensing" class="subsection">Licensing</h4>
		<p>When it comes to associating machine readable licenses with knowledge graphs, the W3C Open Digital Rights Language (ODRL)&nbsp;<? echo $references->cite("odrl"); ?> provides an information model and related vocabularies that can be used to specify permissions, duties, and prohibitions with respect to actions relating to assets. ODRL supports fine-grained descriptions of digital rights that are represented as – and thus can be embedded within – graphs. Figure&nbsp;<? echo ref("fig:license"); ?> illustrates a license granting the assignee the permission to <span class="gnode">Modify</span>, <span class="gnode">Distribute</span>, and <span class="gnode">Derive</span> work from the <span class="gnode">Event Graph</span> (e.g., Figure&nbsp;<? echo ref("fig:delg"); ?>); however the assignee is obliged to <span class="gnode">Attribute</span> the copyright holder. From a modelling perspective, ODRL can be used to model several well known license families, for instance Apache, Creative Commons (CC), and Berkeley Software Distribution (BSD), to name but a few&nbsp;<? echo $references->cite("CabrioAV14,panasiuk2018modeling"); ?>. Additionally, <? echo $references->citet("CabrioAV14"); ?> propose methods to automatically extract machine-readable licenses from unstructured text. From a reasoning perspective, license compatibility validation and composition techniques&nbsp;<? echo $references->cite("villata2012licenses,guido_heuristics_2013,MoreauSPD19"); ?> can be used to combine knowledge graphs that are governed by different licenses. Such techniques are employed by the the Data Licenses Clearance Center (DALICC), which includes a library of standard machine readable licenses, and tools that enable users both to compose arbitrary custom licenses and also to verify the compatibility of different licenses&nbsp;<? echo $references->cite("pellegrini2019DALICC"); ?>.</p>

		<figure id="fig-license">
			<img src="images/fig-license.svg" alt="A license for event data, along with permissions, actions, and obligations"/>
			<figcaption>A license for event data, along with permissions, actions, and obligations</figcaption>
		</figure>

		<h4 id="sssec-usage-policies" class="subsection">Usage policies</h4>
		<p>Access control policies based on edge patterns can be used to restrict access to parts of a knowledge graph&nbsp;<? echo $references->cite("Reddivari2005,Flouris2010,Kirrane2013"); ?>. WebAccessControl (WAC)<? echo footnote("WAC, <a class=\"uri\" style=\"display:inline\" href=\"http://www.w3.org/wiki/WebAccessControl\">http://www.w3.org/wiki/WebAccessControl</a>"); ?> is an access control framework for graphs that uses WebID for authentication and provides a vocabulary for specifying access control policies. Extensions of this WAC vocabulary have been proposed to capture privacy preferences&nbsp;<? echo $references->cite("SaccoP11"); ?> and to cater for contextual constraints&nbsp;<? echo $references->cite("Villata2011,Costabello2012"); ?>. Although ODRL is primarily used to specify licenses, profiles to additionally specify access policies&nbsp;<? echo $references->cite("steyskal2014"); ?> and regulatory obligations&nbsp;<? echo $references->cite("agarwal2018legislative,devos2019ODRL"); ?> have also been proposed in recent years, as discussed in the survey by <? echo $references->citet("kirrane2017access"); ?>.</p>
		<p>As a generalisation of access policies, usage policies specify how data can be used: what kinds of processing can be applied, by whom, for what purpose, etc. The example usage policy presented in Figure&nbsp;<? echo ref("fig:usage"); ?> states that the process <span class="gnode">Analyse</span> of <span class="gnode">Location Graph</span> can be performed on <span class="gnode">Internal Servers</span> by members of <span class="gnode">Company Staff</span> in order to provide <span class="gnode">Event Recommendations</span>. Vocabularies for usage policies have been proposed by the SPECIAL H2020 project&nbsp;<? echo $references->cite("special"); ?> and the W3C Data Privacy Vocabularies and Controls Community Group (DPVCG)&nbsp;<? echo $references->cite("dpv,bonatti2019big"); ?>. Once specified in these vocabularies, usage policies can then be used to verify that data processing conforms to legal norms and to the consent provided by subjects&nbsp;<? echo $references->cite("DelanauxBRT18,bonatti2019big"); ?>.</p>

		<figure id="fig-usage">
			<img src="images/fig-usage.svg" alt="A policy for usage of a sub-graph of location data in the knowledge graph"/>
			<figcaption>A policy for usage of a sub-graph of location data in the knowledge graph</figcaption>
		</figure>

		<h4 id="sssec-encryption" class="subsection">Encryption</h4>
		<p>Rather than internally controlling usage, the tourist board could use encryption mechanisms on parts of the published knowledge graph, for example relating to reports of crimes, and provide keys to partners who should have access to the plaintext. While a straightforward approach is to encrypt the entire graph (or sub-graphs) with one key, more fine-grained encryption can be performed for individual nodes or edge-labels in a graph, potentially providing different clients access to different information through different keys&nbsp;<? echo $references->cite("giereth2005partial"); ?>. The CryptOntology&nbsp;<? echo $references->cite("gerbracht2008possibilities"); ?> can further be used to embed details about the encryption mechanism used within the knowledge graph. Figure&nbsp;<? echo ref("fig:crypto"); ?> illustrates how this could be used to encrypt the names of claimants from Figure&nbsp;<? echo ref("fig:direct"); ?>, storing the ciphertext <span class="gnode">zhk…kjg</span>, as well as the key-length and encryption algorithm used. In order to grant access to the plaintext, one approach is to encrypt individual edges with symmetric keys so as to allow specific types of edge patterns to only be executed by clients with the appropriate key&nbsp;<? echo $references->cite("kasten2013towards"); ?>. This approach can be used, for example, to allow clients who know a claimant ID (e.g., <span class="gnode">Claimant-XY12SDA</span>) and have the appropriate key to find (only) the name of the claimant through an edge pattern <span class="gnode">Claimant-XY12SDA</span><? echo esource(); ?><span class="edge">Claimant-name</span><? echo etipr(); ?><span class="gvar"><strong>?name</strong></span>. A key limitation of this approach, however, is that it requires attempting to decrypt all edges to find all possible solutions. A more efficient alternative is to combine functional encryption and specialised indexing to retrieve solutions from the encrypted graph without attempting to decrypt all edges&nbsp;<? echo $references->cite("FernandezKPS17"); ?>.</p>

		<figure id="fig-crypto">
			<img src="images/fig-crypto.svg" alt="Directed edge-labelled graph with the name of the claimant encrypted; plaintext elements are dashed and may be omitted from published data (possibly along with encryption details)"/>
			<figcaption>Directed edge-labelled graph with the name of the claimant encrypted; plaintext elements are dashed and may be omitted from published data (possibly along with encryption details)</figcaption>
		</figure>

		<h4 id="sssec-anonymisation" class="subsection">Anonymisation</h4>
		<p>Consider that the tourist board acquires information on transport taken by individuals within the country, which can be used – not only by the board, but potentially other stakeholders, such as travel companies – to understand trajectories taken by tourists. However, from a data-protection perspective, it would be advisable to anonymise the knowledge graph to avoid leaking the personal travel history of individuals.</p>
		<p>A first approach to anonymisation is to suppress and generalise knowledge in a graph such that individuals cannot be identified, based on \(k\)-anonymity&nbsp;<? echo $references->cite("samarati1998protecting"); ?><? echo footnote("\\(k\\)-anonymity guarantees that the data of an individual is indistinguishable from at least \\(k-1\\) other individuals."); ?>, \(l\)-diversity&nbsp;<? echo $references->cite("li2007t"); ?><? echo footnote("\\(l\\)-diversity guarantees that sensitive data fields have at least \\(l\\) diverse values within each group of individuals; this avoids leaks such as that all tourists from Austria (a group of individuals) in the data have been pick-pocketed (a sensitive attribute), which would reveal sensitive information about individuals from Austria."); ?>, etc. Approaches that apply \(k\)-anonymity on graphs identify and suppress “quasi-identifiers” that would allow a given individual to be distinguished from fewer than \(k-1\) other individuals&nbsp;<? echo $references->cite("radulovic2015towards,HeitmannEtAl2017"); ?>. Figure&nbsp;<? echo ref("fig:anonymised"); ?> illustrates a possible result of \(k\)-anonymisation for a sub-graph describing a flight passenger, where quasi-identifiers (passport, plane ticket) have been converted into blank nodes, ensuring that the passenger (the dashed blank node) cannot be distinguished from \(k-1\) other individuals. In the context of a graph, however, <em>neighbourhood attacks</em>&nbsp;<? echo $references->cite("ZhouP11"); ?> – using information about neighbours – can also break \(k\)-anonymity, where we also suppress the day and time of the flight, which, though not sensitive information per se, could otherwise break \(k\)-anonymity for passengers (if, for example, a particular flight had fewer than \(k\) males from the U.S. onboard). The graph shown in Figure&nbsp;<? echo ref("fig:anonymised"); ?> then offers \(k\)-anonymity for the particular individual assuming that at least \(k\) male passengers from the U.S. flew during December 2018 from Arica to Santiago.</p>

		<figure id="fig-anonymised">
			<img src="images/fig-anonymised.svg" alt="Anonymised sample of a directed edge-labelled graph describing a passenger (dashed) of a flight"/>
			<figcaption>Anonymised sample of a directed edge-labelled graph describing a passenger (dashed) of a flight</figcaption>
		</figure>

		<p>More complex neighbourhood attacks may rely on more abstract graph patterns, observing that individuals can be deanonymised purely from knowledge of the graph structure, even if all nodes and edge labels are left blank; for example, if we know that a team of \(k-1\) players take flights together for a particular number of away games, we could use this information for a neighbourhood attack that reveals the set of players in the graph. Hence a number of guarantees specific to graphs have been proposed, including \(k\)-degree anonymity&nbsp;<? echo $references->cite("LiuT08"); ?>, which ensures that individuals cannot be deanonymised by attackers with knowledge of the degree of particular individuals. The approach is based on minimally modifying the graph to ensure that each node has at least \(k-1\) other nodes with the same degree. A stronger guarantee, called \(k\)-isomorphic neighbour anonymity&nbsp;<? echo $references->cite("ZhouP08"); ?>, avoids neighbourhood attacks where an attacker knows how an individual is connected to nodes in their neighbourhood; this is done by modifying the graph to ensure that for each node, there exist at least \(k-1\) nodes with isomorphic (i.e., identically structured) neighbourhoods elsewhere in the graph. Both approaches only protect against attackers with knowledge of bounded neighbourhoods. An even stronger notion is that of \(k\)-automorphism&nbsp;<? echo $references->cite("ZouCO09a"); ?>, which ensures that for every node, it is structurally indistinguishable from \(k-1\) other nodes, thus avoiding any attack based on structural information (as a trivial example, a \(k\)-clique or a \(k\)-cycle satisfy \(k\)-automorphism). Many of these techniques for anonymisation of graph data were motivated by social networks&nbsp;<? echo $references->cite("NarayananS09"); ?>, though they can also be applied to knowledge graphs, per the work of <? echo $references->citet("LinT17"); ?>, who adapt \(k\)-automorphism for directed edge-labelled graphs (specifically RDF graphs).</p>
		<p>While the aforementioned approaches anonymise data, a second approach is to apply anonymisation when answering queries, such as adding noise to the solutions in a way that preserves privacy. One approach is to apply \(\varepsilon\)-differential privacy&nbsp;<? echo $references->cite("Dwork:2006:DP:2097282.2097284"); ?><? echo footnote("\\(\\varepsilon\\)-differential privacy ensures that the probability of a given result from a process (e.g., query) applied to data, to which random noise is added, differs no more than \\(e^\\varepsilon\\) when the data includes or excludes any individual."); ?> for querying graphs&nbsp;<? echo $references->cite("Silva2017"); ?>. Such mechanisms are typically used for aggregate (e.g., count) queries, where noise is added to avoid leaks about individuals. To illustrate, differential privacy may allow for counting the number of passengers of specified nationalities taking specified flights, adding (just enough) random noise to the count to ensure that we cannot tell, within a certain probability (controlled by \(\varepsilon\)), whether or not a particular individual took a flight, where, intuitively speaking, we would require (proportionally) less noise for nationalities with many passengers in the data, but more noise to “hide” passengers from more uncommon nationalities.</p>
		<p>These approaches require information loss for stronger guarantees of privacy; which to choose is thus heavily application dependent. If the anonymised data are to be published in their entirety as a “dump”, then an approach based on \(k\)-anonymity can be used to protect individuals, while \(l\)-diversity can be used to protect groups. On the other hand, if the data are to be made available, in part, through a query interface, then \(\varepsilon\)-differential privacy is a more suitable framework.</p>
		</section>
	</section>
